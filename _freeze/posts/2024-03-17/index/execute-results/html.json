{
  "hash": "12953b2f9a02f6878127812385923339",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Cropping an image using a bash script\"\ndescription: \"Here I show how to crop an image using imagemagick covert function\"\n#image: \"preview.png\"\ncomments:\n  giscus:\n    repo: \"adam-coates/adam-coates.github.io\"\n    mapping: \"title\"\ndate: \"2024-03-17\"\ncategories: [\"bash\"]\ndraft: false #  setting this to  will prevent your post from appearing on your listing page until you're ready\ncss: style.css\n---\n\n### Why? \n\nIf you're like me and have a lot of images to crop regularly then a more efficient way to crop is probably something that you need! \n\nI used to do all my cropping manually with the mouse, and I will probably still do some cropping with the mouse. But when I often have a set of images that all need to be cropped then I always try to find the fastest way to do this in bulk. \n\n### Theres many ways to tackle this issue\n\nOf course there are pre-made software that will do this for you, and there are Python ways, C and C++ ways, using PowerPoint, Paint, PhotoShop (dare I say it) even MATLAB ways to achieve this. Yet [ImageMagick](https://imagemagick.org/index.php) has always been around! In fact it was made way back in 1987 and now can easily read and write over 200 image file formats [according to Wikipedia](https://en.wikipedia.org/wiki/ImageMagick).\n\nBut aside from the extensive functionality, you can create images directly from the command line in bash. This means that you quite easily loop over all files in a directory and subject each file to the exact same editing options that you want them to have. \n\nAnd this is great, especially for scientific papers since having a figure x number of pixels too big for some journals won't cut the mustard.\n\n### How to make/ run the script\n\nSo since I always need to crop fMRI images in particular ways, (i.e. maybe I want to crop and only show a particular region for each participant), it would be relatively easy to achieve this. \n\nTake the following example. \n\n\n<center>\n\n![Here I have manually drawn a segmentation in mni space and we see the coronal view of the brain at `y = -4`](./fs_eg.png)\n\n</center>\n\nLet's suppose I want to crop this region out and make a zoomed in part of this to get a closer look at the activation in this region. \n\nI *could* do this in PowerPoint but now imagine I have 100 participants all with the same coloured region. \n\n\n\n### The bash script\n\nThe full script will be available on my GitHub <a href=\"https://github.com/adam-coates/imgCrop\" class=\"button\">here</a>\n\n- In the interest of keeping this blog short, I want to avoid talking about how arguments are parsed in the script but instead about what the script really does and the output.\n\n\n```{bash}\n#!/usr/bin/env bash\n# ... the code runs as a function and before this there is only a case statement and some variables are predefined, please see full script on my GitHub\n\n# ---------------------\n#          1\n# ---------------------\n\n# Create a temporary text file\ntemp_textfile=$(mktemp \"$(dirname \"$input_file\")/temp_file.XXXXXX.txt\")\n\n# Convert the image to a text file\nconvert \"$input_file\" txt:- > \"$temp_textfile\"\n\n# Find all coordinates of the specified color\ncoordinates=$(grep \"srgb($color)\" \"$temp_textfile\" | cut -d ':' -f 1)\n\n# ---------------------\n#          2\n# ---------------------\n\n# Find the minimum and maximum x and y coordinates\nmin_x=$(echo \"$coordinates\" | cut -d ',' -f 1 | sort -n | head -n 1)\nmax_x=$(echo \"$coordinates\" | cut -d ',' -f 1 | sort -n | tail -n 1)\nmin_y=$(echo \"$coordinates\" | cut -d ',' -f 2 | sort -n | head -n 1)\nmax_y=$(echo \"$coordinates\" | cut -d ',' -f 2 | sort -n | tail -n 1)\n\n# Add padding to the minimum and maximum x and y coordinates\nmin_x=$((min_x - padding))\nmax_x=$((max_x + padding))\nmin_y=$((min_y - padding))\nmax_y=$((max_y + padding))\n\n# ---------------------\n#          3\n# ---------------------\n\nif [ \"$type\" == \"crop\" ]; then\n    echo \"Crop\"\n    temp_file=$(mktemp \"$(dirname \"$input_file\")/temp.XXXXXX.png\")\n    convert -size $(identify -format \"%wx%h\" \"$input_file\") xc:black -fill \"white\" \\\n        -draw \"rectangle $min_x,$min_y $max_x,$max_y\" png:- > \"$temp_file\"\n    convert \"$input_file\" \"$temp_file\" -alpha off -compose copy_opacity \\\n        -composite -trim +repage -geometry x$(identify -format \"%h\" \"$temp_file\") \"$output_file\"\n    # remove temp file\n    rm \"$temp_file\"\nelse\n\n# ---------------------\n#          4\n# ---------------------\n\n    echo \"Box\"\n    # Draw bounding box around all the identified coordinates\n    convert \"$input_file\" -fill none -stroke white -strokewidth 3 \\\n        -draw \"stroke-dasharray 10 10 rectangle $min_x,$min_y $max_x,$max_y\" \"$output_file\"\nfi\n\n# Remove the temporary text file\nrm \"$temp_textfile\"\n```\n\n\n1. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}