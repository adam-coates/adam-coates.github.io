{
  "hash": "0b3d6ee358b7ee46b5724cc078a7958e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"A completion source for Neovim\"\ndescription: \"How I set up snippets and language server protocols for code completion\"\n#image: \"preview.png\"\ncomments:\n  giscus:\n    repo: \"adam-coates/adam-coates.github.io\"\n    mapping: \"title\"\ndate: \"2024-04-01\"\ncategories: []\ndraft: false #  setting this to  will prevent your post from appearing on your listing page until you're ready\ncss: style.css\n---\n\n### What language server protocols are? \n\nIn Neovim, VScode, Sublime Text or emacs, all use something called language server protocols (LSPs). LSPs are \"language intelligence tools\" and essentially offer your code editor of choice a way to know \n\n> 1. what coding language you're currently editing in \n> 2. which documentation to provide for said language\n> 3. how to auto complete in said language \n\nFor example, if you wanted to create some Python code, how can you speed up the process of writing code. \n\nThink of LSPs as kind of like a smart dictionary. \n\n#### Neovim's code completion system\n\nOf course, with Neovim there are a bunch of different types of plugins that you can use, some of which achieve the same kind of functionailty but with slightly different features. \n\nHowever, for the setup that I use, I use <a href=\"https://github.com/hrsh7th/nvim-cmp\" class=\"button\">nvim-cmp</a> which is a completion engine plugin. This means that essentially I can provide nvim-cmp a list of sources in which I want to use to carry out autocompletion. \n\nI use another plugin called <a href=\"https://github.com/hrsh7th/cmp-nvim-lsp\" class=\"button\">cmp-nvim-lsp</a> and this is specifically used for LSP completions that I will talk about in the next blog here.\n\nThese include: \n\n- snippets (including my own snippets)\n- completions from path I'm writing\n- completions from current document (if a document contains a word then a text completion is available)\n- Zotero reference snippets (useful for academic writing)\n- completions from LSPs\n\n\nThis sounds like a lot and it probably is therefore, I think for the purpose of the blog, this will be split into two parts. This part will explain and show the part of my configuration that carries out completion from *non-LSP* sources. In the next blog, I talk about how to install and manage LSP sources and how to implement them as part of autocompletion. \n\n### Snippets\n\nSnippets are great. Have you ever started to write a for loop in bash and then switch to Python and forget the correct syntax for a for loop? Or have you ever wanted to define a function in R only to forget how to do the exact same in bash? \n\nThis is where snippets come in handy. I always forget for instance how to construct a *proper* table in markdown. I hardly ever remember how to do that. \n\nLets start by looking at the first few lines of code for this plugin and then to look at how my snippets are set up and finally how I have defined by own snippets. \n\n\n```{lua}\nreturn {\n  \"hrsh7th/nvim-cmp\",\n--  event = \"VeryLazy\",\n  dependencies = {\n    \"hrsh7th/cmp-buffer\", -- source for text in buffer\n    \"hrsh7th/cmp-path\", -- source for file system paths\n    \"L3MON4D3/LuaSnip\", -- snippet engine\n    \"saadparwaiz1/cmp_luasnip\", -- for autocompletion\n    \"rafamadriz/friendly-snippets\", -- useful snippets\n    \"onsails/lspkind.nvim\", -- vs-code like pictograms\n    \"jalvesaq/cmp-zotcite\",\n  },\n\n\n```\n\n\n\n### Completions from path\n\n### Completions from the current document (otherwise know as buffer)\n\n### Zotero completions \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}